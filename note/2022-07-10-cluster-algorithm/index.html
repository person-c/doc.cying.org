<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-02-05">

<title>. - Cluster algorithm</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="style.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">.</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../slides.html"> 
<span class="menu-text">Slides</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#相似度衡量similarity" id="toc-相似度衡量similarity" class="nav-link active" data-scroll-target="#相似度衡量similarity">相似度衡量(similarity)</a>
  <ul class="collapse">
  <li><a href="#相似系数核函数kx-y以及dtw" id="toc-相似系数核函数kx-y以及dtw" class="nav-link" data-scroll-target="#相似系数核函数kx-y以及dtw">相似系数，核函数<span class="math inline">\(K(x, y)\)</span>以及<em>DTW</em></a></li>
  <li><a href="#距离" id="toc-距离" class="nav-link" data-scroll-target="#距离">距离</a>
  <ul class="collapse">
  <li><a href="#数值变量" id="toc-数值变量" class="nav-link" data-scroll-target="#数值变量">数值变量</a></li>
  <li><a href="#二元变量" id="toc-二元变量" class="nav-link" data-scroll-target="#二元变量">二元变量</a></li>
  <li><a href="#分类变量" id="toc-分类变量" class="nav-link" data-scroll-target="#分类变量">分类变量</a></li>
  <li><a href="#有序变量" id="toc-有序变量" class="nav-link" data-scroll-target="#有序变量">有序变量</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#聚类算法" id="toc-聚类算法" class="nav-link" data-scroll-target="#聚类算法">聚类算法</a>
  <ul class="collapse">
  <li><a href="#hierarchical-methods" id="toc-hierarchical-methods" class="nav-link" data-scroll-target="#hierarchical-methods">Hierarchical methods</a></li>
  <li><a href="#partition-based-methods" id="toc-partition-based-methods" class="nav-link" data-scroll-target="#partition-based-methods">Partition-based methods</a></li>
  <li><a href="#density-based-methods" id="toc-density-based-methods" class="nav-link" data-scroll-target="#density-based-methods">Density-based methods</a></li>
  <li><a href="#grid-based-method" id="toc-grid-based-method" class="nav-link" data-scroll-target="#grid-based-method">Grid-based method</a></li>
  <li><a href="#model-based-methods" id="toc-model-based-methods" class="nav-link" data-scroll-target="#model-based-methods">Model-based methods</a></li>
  </ul></li>
  <li><a href="#data-reduction" id="toc-data-reduction" class="nav-link" data-scroll-target="#data-reduction">Data reduction</a></li>
  <li><a href="#result-asessment" id="toc-result-asessment" class="nav-link" data-scroll-target="#result-asessment">result asessment</a>
  <ul class="collapse">
  <li><a href="#外部评价指标" id="toc-外部评价指标" class="nav-link" data-scroll-target="#外部评价指标">外部评价指标</a></li>
  <li><a href="#内部评价指标" id="toc-内部评价指标" class="nav-link" data-scroll-target="#内部评价指标">内部评价指标</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Cluster algorithm</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 5, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Note:该文章基本只是对几篇文章的整合，只有细微的细改，原文章在参考下。</p>
<p>参考：<br>
<a href="https://www.zhihu.com/question/34554321/answer/64372216">相似性衡量，聚类算法以及data reduction的整体介绍</a><br>
<a href="https://www.zhihu.com/collection/789745371">距离计算的详细内容，每种聚类方法的实现过程，example</a><br>
<a href="https://zhuanlan.zhihu.com/p/530944459">聚类结果的内部价指标</a><br>
<a href="https://zhuanlan.zhihu.com/p/343667804">聚类结果的外部评价指标</a></p>
<p>聚类分析：根据样本特征计算样本距离。需要考虑的点，聚类算法，相似度的衡量。</p>
<section id="相似度衡量similarity" class="level1">
<h1>相似度衡量(similarity)</h1>
<section id="相似系数核函数kx-y以及dtw" class="level2">
<h2 class="anchored" data-anchor-id="相似系数核函数kx-y以及dtw">相似系数，核函数<span class="math inline">\(K(x, y)\)</span>以及<em>DTW</em></h2>
<p>相似系数，包括夹角余弦和相关系数。其主要优势在于不受原线性变换的影响，可以轻松转化为距离，但其运算速度比距离法慢的多，当维数很高的时候。</p>
<p>核函数<span class="math inline">\(K(x, y)\)</span>， 定义在<span class="math inline">\(R^d * R^d\)</span>的二元函数，本质也是距离。核函数的功能是把数据从低维到高维进行投影。</p>
<p><em>DTW(dynamic time wraping)</em>。可以用于计算两个不同长度向量的距离，也可以对两对向量中不同时间段的数据做匹配。主要用于时间序列分析。</p>
</section>
<section id="距离" class="level2">
<h2 class="anchored" data-anchor-id="距离">距离</h2>
<section id="数值变量" class="level3">
<h3 class="anchored" data-anchor-id="数值变量">数值变量</h3>
<ul>
<li><p>Minkowski距离：其实就是<span class="math inline">\(L_p\)</span> norm。考虑两个向量， <span class="math inline">\(X = (x_1, x_2, ..., x_p)\)</span>, <span class="math inline">\(Y = (y_1, y_2, ..., y_p)\)</span>. <span class="math display">\[
d(X, Y) = \sqrt[q]{\lvert(x_1 - y_1)\rvert^q + \lvert(x_2 - y_2)\rvert^q + ... + \lvert(x_p - y_p)\rvert^q}
\]</span></p></li>
<li><p>Manhattan距离：Minkowski，q = 1的特例。</p></li>
</ul>
<p><span class="math display">\[
d(X, Y) = \lvert(x_1 - y_1)\rvert + \lvert(x_2 - y_2)\rvert + ... + \lvert(x_p - y_p)\rvert
\]</span></p>
<ul>
<li><p>Euclidean距离：Minkowski, q = 2的特例。 <span class="math display">\[
d(X, Y) = \sqrt[2]{\lvert(x_1 - y_1)\rvert^2 + \lvert(x_2 - y_2)\rvert^2 + ... + \lvert(x_p - y_p)\rvert^2}
\]</span></p></li>
<li><p>supremum距离,也叫切比雪夫距离， <span class="math inline">\(q \rightarrow +\infty\)</span></p></li>
</ul>
<p>Mahalanobis距离：权重向量 <span class="math inline">\(W = (\omega_1, \omega_2, ...,
\omega_p)\)</span>，主要用于<em>Gaussian Mixture Model(GMM)</em></p>
<p><span class="math display">\[
d(X, Y) = \sqrt[q]{\omega_1*\lvert(x_1 - y_1)\rvert^q + \omega_2*\lvert(x_2 - y_2)\rvert^q + ... +\omega_p* \lvert(x_p - y_p)\rvert^q}
\]</span></p>
<p>Note: 考虑到不同特征的尺度不一致，对特征做标准化处理。<span class="math inline">\(Z_f = \frac{X_f - mean_f}{S_f}\)</span></p>
</section>
<section id="二元变量" class="level3">
<h3 class="anchored" data-anchor-id="二元变量">二元变量</h3>
<p><span class="math display">\[d(X, Y) = \frac{unpaired\ features}{unpaired\ feature + paired\ positive}
\]</span></p>
<p>Note: 为什么分母没有考虑<span class="math inline">\(paired\ negativae\)</span>,因为<span class="math inline">\(paired\ negative\)</span> 说明是两者都没有的属性，那这样的属性可以说是无穷多的，计算上也没什么意义，所以不考虑，该说法由<em>Jaccard</em>提出，所以该距离称为<em>Jaccard distance</em>。</p>
</section>
<section id="分类变量" class="level3">
<h3 class="anchored" data-anchor-id="分类变量">分类变量</h3>
<ul>
<li>简单匹配</li>
</ul>
<p><span class="math display">\[
d(X, Y) = \frac{paired\ feature}{category\ number}
\]</span></p>
<ul>
<li>分类变量二值化，即将多类归为两类。</li>
</ul>
</section>
<section id="有序变量" class="level3">
<h3 class="anchored" data-anchor-id="有序变量">有序变量</h3>
<p>考虑 <span class="math inline">\(Level \in{low, middle, high, ...}\)</span></p>
<ol type="1">
<li>用<span class="math inline">\({1, 2, ..., N}\)</span>定义 <span class="math inline">\(level\)</span>排序。</li>
<li>对<span class="math inline">\(level\)</span>进行<span class="math inline">\(z\ score\)</span>标准化。</li>
<li>计算<span class="math inline">\(level\)</span>的Minkowski距离。</li>
</ol>
</section>
</section>
</section>
<section id="聚类算法" class="level1">
<h1>聚类算法</h1>
<section id="hierarchical-methods" class="level2">
<h2 class="anchored" data-anchor-id="hierarchical-methods">Hierarchical methods</h2>
<p>主要有两种路径： agglomerative 和divisive, 也可以理解为自下而上法(bottom-up) 和自上而下法(top-down) 。自下而上法，就是一开始每个个体(object) 都是一个类， 然后根据巧linkage寻找同类， 最后形成一个”类” 。自上而下法就是反过来， 一开始所有个体都属于一个” 类， 然后根据linkage排除异己，最后每个个体都成为一个” 类” 。这两种路径本质上没有优劣之分，只是在实际应用的时候要根据数据特点以及你想要的” 类” 的个数，来考虑是自上而下更快还是自下而上更快。至于根据Linkage 判断” 类” 的方法就是楼上所提到的最短距离法、最长距离法、中间距离法、类平均法等等（其中类平均往往被认为是最常用也最好用的方法， 一方面因为其良好的单调性，另一方面因为其空间扩张/ 浓缩的程度适中），HierarchicaI methods 中比较新的算法有BIRCH (BaIanced lterative Reducing and clustering Using Hierarchies) 主要是在数据体量很大的时候使用，而且数据类型是numerical; ROCK (A HierarchicaI CIustering Algorithm for CategoricaI Attri butes）主用在categorical 的数据类型上； ChameIeon (A HierarchicaI CIustering Algorithm Using Dynamic ModeIing) 里用到的linkage是kNN (k-nearest-neighbor) 算法，并以此构建一个graph。Chameleon的聚类效果被认为非常强大，比BIRCH 好用，但运算复杂度很高。</p>
<ul>
<li>example</li>
</ul>
<p>把每一个单个的观测都视为一个类，而后计算各类之间的距离，选取最相近的两个类，将它们合并为一个类。新的这些类再继续计算距离，合并到最近的两个类。如此往复，最后就只有一个类。然后用树状图记录这个过程，这个树状图就包含了我们所需要的信息。类的数量取决于你从树状图哪里剪。</p>
<ol type="1">
<li>计算类与类之间的距离，用邻近度矩阵记录。</li>
<li>将最近的两个类合并为一个新的类。</li>
<li>根据新的类，更新邻近度矩阵。</li>
<li>重复2. 3。</li>
<li>到只只剩下一个类的时候，停止。</li>
</ol>
</section>
<section id="partition-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="partition-based-methods">Partition-based methods</h2>
<p>其原理简单来说就是，想象你有一堆散点需要聚类，想要的聚类效果就是”类内的点都足够近，类间的点都足够远” 。首先你要确定这堆散点最后聚成几类，然后挑选几个点作为初始中心点，再然后依据预先定好的启发式算法(heuristic algorithms)给数据点点做迭代重置（iterative relocation),直到最后到达”类内的点都足够近，类间的点都足够远” 的目标效果。也正是根据所渭的”启发式算法”,形成了k-means算法及其变体包括k-medoids 、k-modes 、k-medians、kernel k-means 等算法。k-means 对初始值的设置很敏感，所以有了k-means 十十、intelligent k-means 、genetic k-means; k-means 对噪声和离群值非常敏感，所以有了k-medoids 和k-medians; k-means只用于numerical 类型数据，不适用 于categorical 类型数据，所以k-modes; k-means不能解决非凸(non-convex) 数据，所以有了kernel k-meanso 另外，很多教程都告诉我们Partition-based methods 聚类多适用于中等体量的数据集，但我们也不知道中等’ 到底有多’ 中” ，所以不妨理解成， 数据集越大，越有可能陷入局部最小。</p>
<ul>
<li>example k-means</li>
</ul>
<ol type="1">
<li>选择 K 个初始质心，初始质心随机选择即可，每一个质心为一个类。</li>
<li>把每个观测指派到离它最近的质心，与质心形成新的类。</li>
<li>重新计算每个类的质心，所谓质心就是一个类中的所有观测的平均向量（这里称为向量，是因为每一个观测都包含很多变量，所以我们把一个观测视为一个多维向量，维数由变量数决定）。</li>
<li>重复2. 和 3。</li>
<li>直到质心不在发生变化时或者到达最大迭代次数时。</li>
</ol>
</section>
<section id="density-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="density-based-methods">Density-based methods</h2>
<p>k-means解决不了不规则形状的聚类。于是就有了Density-based methods来系统解决这个问题。该方法同时也对噪声数据的处理比较好。其原理简单说画圈，其中要定义两个参数，一个是圈的最大半径，一个是圈里最少应容纳几个点。最后在一个圈里的，就是一个类。DBSCAN (Density-Based SpatiaI Clustering of Applications with Noise) 就是其中的典型，可惜参数设置也是个问题，对这两个参数的设置非常敏感。DBSCAN 的扩展叫OPTICS (Ordering Points To ldentify Clustering Structure) 通过优先对高密度(high density) 进行搜索，然后根据高密度的特点设置参数，改善了DBSCAN的不足。</p>
<ul>
<li>example</li>
</ul>
<p>其核心思想是在数据空间中找到分散开的密集区域，简单来说就是画圈，其中要定义两个参数，一个是圈的最大半径，一个是一个圈里面最少应该容纳多少个点。</p>
<ol type="1">
<li>从数据集中随机选择核心点。<br>
</li>
<li>以核心点为圆心，做半径为V的圆，圆内圈入点的个数满足密度阈值的核心点称为核心对象,每一个核心对象的对应的圈都是一个簇。<br>
</li>
<li>合并这些相互重合的簇。</li>
</ol>
</section>
<section id="grid-based-method" class="level2">
<h2 class="anchored" data-anchor-id="grid-based-method">Grid-based method</h2>
<ul>
<li>example</li>
</ul>
<p>根据网格的聚类其原理是将数据空间划分为网格单元，将数据对象映射到网格单元中，并计算每个单元的密度。根据预设阈值来判断每个网格单元是不是高密度单元，由邻近的稠密单元组成“类”。</p>
<p>1.将数据空间划分为网格单元。<br>
2.依照设置的阈值，判定网格单元是否稠密。<br>
3.合并相邻稠密的网格单元为一类。</p>
</section>
<section id="model-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="model-based-methods">Model-based methods</h2>
<p>这一类方去主要是指基于概率模型的方法和基于神经网络模型的方法，尤其以基于概率模型的方法居多。这里的概率模型主要指概率生成模型(generative Model)，同一”类” 的数据属于同一种概率分布。这种方法的优点就是对” 类” 的划分不那么”坚硬”，而是以概率形式表现，每一类的特征也可以用参数来表达；但缺点就是执行效率不高，特别是分布数量很多并且数据量很少的时候。其中最典型、也最常用的方法就是高斯混合模型(GMM, Gaussian Mixture Models)。基于神经网络模型的方法主要就是指SO(SeIfOrganized Maps) 了。</p>
</section>
</section>
<section id="data-reduction" class="level1">
<h1>Data reduction</h1>
<p>数据简化(data reduction)，这个环节optional。其实第二部分提到的有些算法就是对数据做了简化，才得以具备处理大规模数据的能力，比如BIRCHO。但其实你可以任意组合，所以理论上把数据简化的方法和上面提到的十几种聚类算法结合使用，可以有上百个算法了。</p>
<ul>
<li><p>变换(Data Transformation)：离散傅里叶变换（Discrete Fourier Transformation)可以提取数据的频域(frequency domain)信息，离散小波变换(Discrete Wavelet Transformation)除了频域之外，还可以提取到时域(temporal domain)信息。</p></li>
<li><p>降维(Dimensionality Reduction)：在降维的方法中，PCA (Principle Component Analysis)和SVD (Singular Value Decomposition) 作为线性方法，受到最广泛的应用。还有像MDS (Multi-DimensionaI Scaling) 什么的，不过只是作为PCA 的一个扩展，给我的感觉是中看不中用。这几个方法局限肯定是无法处理非线特征明显的数据。处理非线性降维的去主要是流形学习(Manifold Learning)，这又是一大块内容，里面集中常见的算法包括ISOMAP 、LLE (LocaIIy Linear Embedding) 、MVU (Maximum variance unfolding)Laplacian eigenmaps 、Hessian eigenmaps 、Kernel PCA 、ProbabiIistic PCA 等等。关于降维在聚类中的应用，最著名的应该就是谱聚类(Spectral Clustering) 就是先用LapIacian eigenmaps 对数据降维（简单地说，就是先将数据转换成邻接矩阵或相似性矩阵，再转换成LapIacian 矩阵，再对LapIacian 矩阵进特征分解，把最小的K个特征向量列在一起），然后再使用k-means 完成聚类。谱聚类是个很好的方法， 效果通常比k-means好, 计算复杂度还低，这都要归功于降维的作用。</p></li>
<li><p>抽样(Sampling)：最常用的就是随机抽样(Random Sampling) ， 如果你的数据集特别大，随机抽样就越能显示出它的低复杂性所带来的好处。比如CLARA (CIustering LARge AppIications) 就是因为k-medids 应对不了大规模的数据集， 所以采用sampling的方法。</p></li>
</ul>
</section>
<section id="result-asessment" class="level1">
<h1>result asessment</h1>
<p>对于聚类结果的评价方法一般可以分为内部评估法（internal evaluation）与外部评估方法（external evaluation）。</p>
<p>所谓外部评估方法是指在知道真实标签（ground truth ）的情况下来评估聚类结果的好坏，一般来说在做论文，或者是有少量的标注数据时，都可以用外部评估法选择一个相对最优的聚类模型，然后再应用到其它未被标记的数据中。</p>
<p>所谓内部评估法是不借助于外部信息，仅仅只是根据聚类结果来进行评估，常见的有轮廓系数（Silhouette Coefficient）、Calinski-Harabasz Index等。一般来说，在完全没有标记数据的情况下可以通过这种方式来评估聚类结果的好坏。</p>
<section id="外部评价指标" class="level2">
<h2 class="anchored" data-anchor-id="外部评价指标">外部评价指标</h2>
<ul>
<li>聚类纯度(purity) 与准确率异曲同工，其总体思想就是用聚类正确的数目除以总的样本数，因此常被称为准确率。</li>
</ul>
<p><span class="math display">\[
P = \sum_k\frac{max\ groud\ truth\ number\ in\ cluster\ k }{total\ number}
\]</span></p>
<ul>
<li>Rand Index</li>
</ul>
<p>定义簇(cluster，cluster result), 类(classification, groud truth)。</p>
<p><em>precision</em>,你发现的阳性有多少是真的阳性。<br>
<em>Recall</em>,放出去的阳性，你找回了多少。</p>
<p>TP = 同簇同类的数目<br>
TN = 不同簇不同类的数目<br>
FP = 同簇不同类的数目<br>
FN = 不同簇同类的数目</p>
<p><span class="math display">\[ RI = \frac{TP + TN}{TP + TN + FP + FN} \]</span> <span class="math display">\[ Precision = \frac{TP}{TP + FP} \]</span> <span class="math display">\[ Recall = \frac{TP}{TP + FN} \]</span> <span class="math display">\[ F_\beta = \frac{(\beta^2 + 1)}{\beta^2}\frac{(Precision * Recall)}{Precision + Recall} \]</span></p>
<p>在这里 <span class="math inline">\(RI\)</span> 和 <span class="math inline">\(F_\beta\)</span> 的取值范围均为<span class="math inline">\([0,1]\)</span>, 越大表示聚类效果越好。一般用得较多的是<span class="math inline">\(F1\)</span>，这里 <span class="math inline">\(\beta =1\)</span></p>
<ul>
<li>调整兰德系数(adjusted Rand Index)</li>
</ul>
<p><span class="math display">\[
ARI = \frac{\sum_i\sum_j\tbinom{n_{ij}}{2} - \left[ \sum_i\tbinom{a_i}{2} \sum_b\tbinom{b_j}{2} \right] \bigg/ \tbinom{n}{2}} {\frac{1}{2} * \left[ \sum_i\tbinom{a_i}{2} \sum_j\tbinom{b_j}{2} \right] - \left[ \sum_i\tbinom{a_i}{2} \sum_j\tbinom{b_j}{2} \right] \bigg/ \tbinom{n}{2}}
\]</span></p>
<p>考虑<span class="math inline">\(A\)</span>在三个cluster中数量分别为5, 1, 2. <span class="math inline">\(B\)</span>在三个cluster中数量分别为1, 4, 0. <span class="math inline">\(C\)</span>在三个cluster中的数量分别为0, 1, 3.</p>
<p>X, Y1, Y2, Y3, sums<br>
X1, 5, 1, 2, a1=8<br>
X2, 1, 4, 0, a2=5<br>
X3, 0, 1, 3, a3=4<br>
sums, b1=6, b2=6,b3=5</p>
<p><span class="math display">\[
\sum_i\sum_j\tbinom{n_{ij}}{2} = \tbinom{5}{2} + \tbinom{2}{2} + \tbinom{4}{2} + \tbinom{3}{2} = 20  
\]</span> <span class="math display">\[
\sum_i\tbinom{a_i}{2} = \tbinom{8}{2} + \tbinom{5}{2} + \tbinom{4}{2} = 44  
\]</span> <span class="math display">\[
\sum_j\tbinom{b_j}{2} = \tbinom{6}{2} + \tbinom{6}{2} + \tbinom{5}{2} = 40
\]</span></p>
<p><span class="math display">\[
ARI = \frac{20 - 44 * 40 / 136 }{0.5 * (44 + 40) - 44 * 40 / 136 } = 0.24
\]</span></p>
</section>
<section id="内部评价指标" class="level2">
<h2 class="anchored" data-anchor-id="内部评价指标">内部评价指标</h2>
<p>内部评价指标基本都基于簇内距离，与簇间距离的比值，只是这些距离的含义不同。</p>
<ul>
<li>轮廓系数(Sihouette Coefficient Index) <span class="math display">\[
s(i) = \frac{b(i) - a(i)}{max\{a(i), b(i) \}}
\]</span></li>
</ul>
<p><span class="math display">\[
s = \frac{1}{n} \sum_i^n s_i
\]</span></p>
<p><span class="math inline">\(i\)</span>代表一个样本点，其中<span class="math inline">\(a(i)\)</span>是该样本点在簇类与其它点的均值距离，<span class="math inline">\(b(i)\)</span>是该样本点与其最近的簇的样本点的距离均值，这里所谓的距离最近的簇是该点与其它簇的中心点的距离最近的簇。可以看出<span class="math inline">\(s\)</span>的取值范围为<span class="math inline">\(\left[-1, 1 \right]\)</span></p>
<ul>
<li>Calinski-Harabasz Index(方差比准则) <span class="math display">\[
W = \sum_{k=1}^{k}\omega_k = \sum_{k=1}^{K}\sum_{x\in C_k} (x - c_k)^2
\]</span></li>
</ul>
<p><span class="math display">\[
B = \sum_{k=1}^{k} b_k = \sum_{k=1}^{k} n_k(c_k - c)^2
\]</span></p>
<p><span class="math display">\[
s = \frac{B}{K - 1} \bigg/ \frac{W}{n - K} = \frac{B}{W} \cdot \frac{n - K}{k - 1}
\]</span></p>
<p>其中<span class="math inline">\(\omega_k\)</span>是簇<span class="math inline">\(k\)</span>中所有点与该簇中心点的距离和，<span class="math inline">\(b_k\)</span>是簇<span class="math inline">\(k\)</span>的中心点与所有样本中心点距离乘以簇<span class="math inline">\(k\)</span>的样本点数目。其中<span class="math inline">\(c_k\)</span>为簇<span class="math inline">\(k\)</span>的簇中心，<span class="math inline">\(c\)</span>为所有样本点的中心。<span class="math inline">\(K\)</span>为聚类得到的簇总数，<span class="math inline">\(n\)</span>为样本数目，<span class="math inline">\(n_k\)</span>为簇<span class="math inline">\(k\)</span>的样本数目。</p>
<ul>
<li>Davies-Bouldin Index</li>
</ul>
<p>簇内直径与簇间距离的比值。<br>
首先定义簇内直径<span class="math inline">\(s_i\)</span>等于簇<span class="math inline">\(i\)</span>中所有点与簇中心点的距离均值，簇<span class="math inline">\(i\)</span>与簇<span class="math inline">\(j\)</span>之间的距离为<span class="math inline">\(d_{ij}\)</span>,等于簇<span class="math inline">\(i\)</span>与簇<span class="math inline">\(j\)</span>中心点之间的距离。</p>
<p><span class="math display">\[
R_{ij} = \frac{s_i + s_j}{d_{ij}}
\]</span></p>
<p><span class="math display">\[
DB = \frac{1}{K} \sum_{i,j=1}^K max_{i\neq j} R_{ij}
\]</span></p>
<p><span class="math inline">\(DB\)</span>指数的取值范围在<span class="math inline">\(\left[0, +\infty\right]\)</span>，结果越小聚类效果越好。</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>