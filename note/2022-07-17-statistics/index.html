<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-07-17">

<title>Raining - Statistics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../static/css/font.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Raining</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../slides.html"> 
<span class="menu-text">Slides</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#第一篇-数据产生以及统计描述" id="toc-第一篇-数据产生以及统计描述" class="nav-link active" data-scroll-target="#第一篇-数据产生以及统计描述">第一篇 数据产生以及统计描述</a>
  <ul class="collapse">
  <li><a href="#第一章-描述性统计学探索数据" id="toc-第一章-描述性统计学探索数据" class="nav-link" data-scroll-target="#第一章-描述性统计学探索数据">第一章 描述性统计学探索数据</a></li>
  <li><a href="#第二章-数据产生抽样" id="toc-第二章-数据产生抽样" class="nav-link" data-scroll-target="#第二章-数据产生抽样">第二章 数据产生，抽样</a></li>
  </ul></li>
  <li><a href="#第二篇-当理想照进现实从总体分布到样本分布" id="toc-第二篇-当理想照进现实从总体分布到样本分布" class="nav-link" data-scroll-target="#第二篇-当理想照进现实从总体分布到样本分布">第二篇 当理想照进现实——从总体分布到样本分布</a>
  <ul class="collapse">
  <li><a href="#第一章-大数定理与中心极限定理" id="toc-第一章-大数定理与中心极限定理" class="nav-link" data-scroll-target="#第一章-大数定理与中心极限定理">第一章 大数定理与中心极限定理</a></li>
  <li><a href="#第二章-概率" id="toc-第二章-概率" class="nav-link" data-scroll-target="#第二章-概率">第二章 概率</a></li>
  <li><a href="#第三章-正态分布与二项分布" id="toc-第三章-正态分布与二项分布" class="nav-link" data-scroll-target="#第三章-正态分布与二项分布">第三章 正态分布与二项分布</a></li>
  <li><a href="#第四章-样本分布" id="toc-第四章-样本分布" class="nav-link" data-scroll-target="#第四章-样本分布">第四章 样本分布</a></li>
  </ul></li>
  <li><a href="#第三篇-一叶知秋如何预知未来" id="toc-第三篇-一叶知秋如何预知未来" class="nav-link" data-scroll-target="#第三篇-一叶知秋如何预知未来">第三篇 一叶知秋——如何预知未来</a>
  <ul class="collapse">
  <li><a href="#第一章-线性回归" id="toc-第一章-线性回归" class="nav-link" data-scroll-target="#第一章-线性回归">第一章 线性回归</a></li>
  </ul></li>
  <li><a href="#第四篇-我们距离真相还有多远置信区间和假设检验" id="toc-第四篇-我们距离真相还有多远置信区间和假设检验" class="nav-link" data-scroll-target="#第四篇-我们距离真相还有多远置信区间和假设检验">第四篇 我们距离真相还有多远——置信区间和假设检验</a>
  <ul class="collapse">
  <li><a href="#第一章-confidence-interval" id="toc-第一章-confidence-interval" class="nav-link" data-scroll-target="#第一章-confidence-interval">第一章 Confidence interval</a></li>
  <li><a href="#第二章-假设检验原理" id="toc-第二章-假设检验原理" class="nav-link" data-scroll-target="#第二章-假设检验原理">第二章 假设检验原理</a></li>
  <li><a href="#第三章-假设检验之z检验以及t检验" id="toc-第三章-假设检验之z检验以及t检验" class="nav-link" data-scroll-target="#第三章-假设检验之z检验以及t检验">第三章 假设检验之z检验以及t检验</a></li>
  <li><a href="#第四章-假设检验之卡方检验类别变量研究" id="toc-第四章-假设检验之卡方检验类别变量研究" class="nav-link" data-scroll-target="#第四章-假设检验之卡方检验类别变量研究">第四章 假设检验之卡方检验——类别变量研究</a></li>
  <li><a href="#第五章-假设检验之f检验方差分析" id="toc-第五章-假设检验之f检验方差分析" class="nav-link" data-scroll-target="#第五章-假设检验之f检验方差分析">第五章 假设检验之F检验——方差分析</a></li>
  <li><a href="#第六章-假设检验之多重假设检验" id="toc-第六章-假设检验之多重假设检验" class="nav-link" data-scroll-target="#第六章-假设检验之多重假设检验">第六章 假设检验之多重假设检验</a></li>
  </ul></li>
  <li><a href="#第五篇-从演绎到推断计算机重抽样" id="toc-第五篇-从演绎到推断计算机重抽样" class="nav-link" data-scroll-target="#第五篇-从演绎到推断计算机重抽样">第五篇 从演绎到推断——计算机重抽样</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script>

  // load font(from yihui.org)

  (function (d) {

    // https://www.kirupa.com/html5/detect_whether_font_is_installed.htm

    let canvas = document.createElement('canvas');

    let context = canvas.getContext('2d');

    let text = 'abcdefghijklmnopqrstuvwxyz0123456789';

    context.font = '72px monospace';

    let size = context.measureText(text).width;

    let fonts = [' SC', ' CN', ' TC', ' TW', ''];

    for (let i = 0; i < fonts.length; i++) {

      context.font = "72px '" + 'Source Han Serif' + fonts[i] + "', monospace";

      // no need to load TypeKit if Source Hans Serif has been installed

      if (context.measureText(text).width != size) return;

    }

    let config = { kitId: 'kwz5xar', scriptTimeout: 3000, async: true },

      h = d.documentElement,

      t = setTimeout(function () {

        h.className =

          h.className.replace(/\bwf-loading\b/g, '') + ' wf-inactive';

      }, config.scriptTimeout),

      tk = d.createElement('script'),

      f = false,

      s = d.getElementsByTagName('script')[0],

      a;

    h.className += ' wf-loading';

    tk.src = 'https://use.typekit.net/' + config.kitId + '.js';

    tk.async = true;

    tk.onload = tk.onreadystatechange = function () {

      a = this.readyState;

      if (f || (a && a != 'complete' && a != 'loaded')) return;

      f = true;

      clearTimeout(t);

      try {

        Typekit.load(config);

      } catch (e) {}

    };

    s.parentNode.insertBefore(tk, s);

  })(document);

</script>


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Statistics</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 17, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="第一篇-数据产生以及统计描述" class="level1">
<h1>第一篇 数据产生以及统计描述</h1>
<section id="第一章-描述性统计学探索数据" class="level2">
<h2 class="anchored" data-anchor-id="第一章-描述性统计学探索数据">第一章 描述性统计学探索数据</h2>
<ol type="1">
<li>图形描述</li>
<li>数字描述</li>
</ol>
<ul>
<li><p>数据集中的描述： 均值与中位数，数据对称时均值与中位相等，均值向数据分布（右偏或左偏）偏离。</p></li>
<li><p>数据分散的描述：interquartile range = third quartile - 1st quartile。标准差是用于描述数据分散的常用数值。</p></li>
<li><p>均值和标准差都对少部分很大或很小的值很敏感，可以考虑使用中位数和interquartile range</p></li>
</ul>
</section>
<section id="第二章-数据产生抽样" class="level2">
<h2 class="anchored" data-anchor-id="第二章-数据产生抽样">第二章 数据产生，抽样</h2>
<p>总体（population): entire group we want information<br>
参数（parameter)：quantity about the population we are interested in. 样本（sample): part of population from which we collect information.<br>
统计量（estimate，statistic）：the quantity we are interested in as measured in the sample.</p>
<p>关键：即使一个很小的样本也能产生一个于总体参数相近的估计。</p>
<p>抽样方法：</p>
<ol type="1">
<li>不放回的简单随机抽样（a simple random sampling)。</li>
<li>分层的随机抽样(a stratified random sample)：相似的为一层，然后，在每一层进行一个简单的随机抽样，然后把这些样本组合起来。</li>
</ol>
<p><strong>Bias and chance error</strong>:</p>
<ul>
<li>Bias(systematic error)</li>
</ul>
<ol type="1">
<li>selection bias： a sample of convenience make it more likely to sample certain subjects than others<br>
</li>
<li>non-response bias: less likely to answer a question at a special situation<br>
</li>
<li>voluntary response bias: websites that post reviews of businenss are more likely to get response from customer who had very bad or very good experiences.</li>
</ol>
<ul>
<li>Chance error(sampling error): 随机抽样，估计和总体的偏差，每一次的抽样有不同的chance error。抽样的随机性。</li>
</ul>
<p><span class="math display">\[
estimate = parameter + bias(systematic\ error) + chance\ error(sampling\ error)
\]</span></p>
<p>Note: 增大样本可以减少chance error，并且我们可以计算chance error具体有多大。但是增大样本只是让bias在一个更大的规模上重复，并且我们不能知道bias的大小。</p>
<p><strong>因果分析与关联分析</strong></p>
<p>observation study: 测量一个感兴趣的事的结果，用于观察关联关系。</p>
<p>Association is not causation, there may be confounding factors</p>
<p>Causation experiment(randomized controlled experiments): 1. Subjects are assigned into treatment and control groups. at random.<br>
2. Subjects in controlled group get a placebo to ensure both groups equally affected by the placebo effect: the didea of being treated may have an effect by itself.<br>
3. Double-blind.</p>
<p>More：<br>
<a href="https://www.vox.com/science-and-health/2017/7/7/15792188/placebo-effect-explained">The wired power of placebo effect, explained</a></p>
</section>
</section>
<section id="第二篇-当理想照进现实从总体分布到样本分布" class="level1">
<h1>第二篇 当理想照进现实——从总体分布到样本分布</h1>
<section id="第一章-大数定理与中心极限定理" class="level2">
<h2 class="anchored" data-anchor-id="第一章-大数定理与中心极限定理">第一章 大数定理与中心极限定理</h2>
<p>Three histograms: 1. Probability histogram for producing the data. 2. The histogram of 100 observed tosses. 3. The probability of the statistic.</p>
<p>Law of large numbers: When sample size is large enough, the <span class="math inline">\(\bar{x}_N\)</span> will be likely close to <span class="math inline">\(\mu\)</span> . 1) applied for averages and percentages, but not for sums. 2) sampling with replacement from a population or for simulating data from a probability histogram.</p>
<p>More advanced large number laws: the empirical histaogram will be close to probability to histogram producing the data.</p>
<p>Central limit theory: the sample sum statistic(averages and percentages are sums in disguise) distribution is normal distribution</p>
<p>应用条件：放回抽样，或者每次都从同一个概率分布函数抽样（其实不同的也可以？）<br>
Sample size is large enough.(if no strong skewness, n &gt; 15 is sufficient)</p>
</section>
<section id="第二章-概率" class="level2">
<h2 class="anchored" data-anchor-id="第二章-概率">第二章 概率</h2>
<p>Standard definition: proportion of times this event occurs in many repetitions.<br>
Subjective probability: not based on experiments, different people assign different subjective probabilities to the same event.</p>
<p><strong>Four basic rules</strong></p>
<blockquote class="blockquote">
<p>Complement rule: P(A does not occur) = 1 - P(A)</p>
</blockquote>
<blockquote class="blockquote">
<p>Rules for equally likely outcomes: <span class="math inline">\(P(A) = \frac{
number\ of\ outcomes\ in\ A}{n}\)</span></p>
</blockquote>
<blockquote class="blockquote">
<p>Addition rule: <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are mutually exclusive(don’t occure at the same time), then: <span class="math display">\[ P(A or B) = P(A) + P(B)\]</span></p>
</blockquote>
<blockquote class="blockquote">
<p>Multiplication rule: A and B are independent(one occures doesn’t change the probability that the other occurs),then: <span class="math display">\[P(A and B) = P(A)(B)\]</span></p>
</blockquote>
<p><strong>条件概率（conditional probability)</strong> <span class="math display">\[ P(B|A) = \frac{P(A and B)}{P(A)} \]</span> <strong>General multiplication rule</strong>: <span class="math inline">\(P(A and B) = P(A)P(B|A)\)</span>, special case where A and B are independent: <span class="math inline">\(P(A and B) = P(A)P(B)\)</span>.</p>
<p><strong>Bayes’s rule</strong> <strong>Bayesian analysis</strong></p>
<p><strong>False positives case</strong> <strong>warner’s randomized response model</strong></p>
</section>
<section id="第三章-正态分布与二项分布" class="level2">
<h2 class="anchored" data-anchor-id="第三章-正态分布与二项分布">第三章 正态分布与二项分布</h2>
<p>Normal curve: bell-shaped.<br>
Empirical rule:<br>
About 2/3(68%) fall within one sd of the mean.<br>
About 95% fall within 2 sd of the mean.<br>
About 99.7 fall within 3 sd of the mean.</p>
<p>Standardize data: <span class="math inline">\(z = \frac{height - \bar{x}}{s}\)</span><br>
z meas how many sd the height away from the mean. no unites.</p>
<p>Normal approximation: 1. Finding areas under teh normal curve.(we can look up area to the left of a given value) the empirical rule is a special case of normal approximation.<br>
2. Computing percentiles for normal data: 30% data for normal curve, the height is z sd away from mean.</p>
<p><strong>Binomial probability</strong> <span class="math display">\[
\frac{X(success\ count) - np}{\sqrt{np(1 - p)}} \sim
N(0,1)
\]</span></p>
<p>Note: 简单随机抽样是不放回的抽样，不是二项分布设定，因为每取出一个, 概率P就，改变了;但是如果总体size远大于样本size，那么放回抽样和不放回抽样就是大致一致的，服从于二项分布，服从于正态曲线。</p>
</section>
<section id="第四章-样本分布" class="level2">
<h2 class="anchored" data-anchor-id="第四章-样本分布">第四章 样本分布</h2>
<p>Expected value of the sample average , E(<span class="math inline">\(\bar{x}_N\)</span>) is the population average. Standard error: statistic’s sd(其实就是样本统计量的标准差), tells us roughly how far off the statistic will be from it expected value.</p>
<p><strong>Expected value and <em>SE</em> for average</strong> &gt; E(<span class="math inline">\(\bar{x}_N\)</span>) = <span class="math inline">\(\mu\)</span> (Square root law), <span class="math inline">\(SE(\bar{x}_n) = \frac{\sigma}{\sqrt{n}}\)</span></p>
<blockquote class="blockquote">
<ol type="1">
<li>More lager sample size n, more smaller SE, it can be used to determine sample size to get desired accuarcy</li>
<li>SE don’t depend on the size of the population, only on the size of the sample.</li>
</ol>
</blockquote>
<p><strong>Expected value and <em>SE</em> for sum</strong> &gt; $E(S_n) = n$ , <span class="math inline">\(SE(S_n) = \sqrt{n}\sigma\)</span></p>
<p><strong>Expected value and <em>SE</em> for percentages</strong> Framework for counting and classifying: <span class="math display">\[
E(percentage\ of\ 1s) = 1\mu100%
\frac{\sigma}{\sqrt{n}} 100%
\]</span></p>
<p><strong>Expected value and <em>SE</em> when simulating</strong> A random variable X that is simulated has K possible outcomes , <span class="math inline">\(\mu = \sum_{i=1}^k x_i P(X = x_i),  \sigma^2 =
\sum{i=1}^k (x_i - \mu)^2 P(X = x_i)\)</span></p>
</section>
</section>
<section id="第三篇-一叶知秋如何预知未来" class="level1">
<h1>第三篇 一叶知秋——如何预知未来</h1>
<section id="第一章-线性回归" class="level2">
<h2 class="anchored" data-anchor-id="第一章-线性回归">第一章 线性回归</h2>
<p>Scatter plot three element: direction(slope up or down), form(points cluster around a line or other), strength(how closethe points follow the form)</p>
<p>Summary of pair data: <span class="math inline">\(\bar{x}\)</span>, <span class="math inline">\(s_x\)</span>, <span class="math inline">\(\bar{y}\)</span>, <span class="math inline">\(s_y\)</span>, <span class="math inline">\(r\)</span></p>
<p>How to quantify the strength?<br>
If it is liner former, the correlation coefficient <em>r</em> is a good choice. standardized <span class="math inline">\(x*y\)</span> ,not affected by the scale of either variable. its sign gives the direction and its absolute value gives the strength.</p>
<p>Note: r is only useful for measuring linear association.and correlation does not mean causation</p>
<p>How to get the regression line?<br>
To minimize the MSE(mean squared error), the method of least squares gives the analytic answer: <span class="math inline">\(b = r\frac{s_y}{s_x}\)</span> and <span class="math inline">\(a = \bar{y} - b\bar{x}\)</span>. This line <span class="math inline">\(y = a + bx\)</span> is called the regression line.</p>
<p>Another interpretation of the regression line:<br>
&gt; Computes the average value of y when the first coordinate is near x.<br>
Note: The average often times is the best estimate when no extra information is provided.</p>
<p>向均值回归? regression effect(回归效应)?<br>
因为 1）<span class="math inline">\(\bar{x}\)</span> 的预测值是 <span class="math inline">\(\bar{y}\)</span>， 2）<span class="math inline">\(b = r\frac{s_y}{s_x}\)</span> ，也就是说当<span class="math inline">\(x\)</span>偏离 <span class="math inline">\(\bar{x}\)</span> 一个sd时， <span class="math inline">\(y\)</span>只向 <span class="math inline">\(\bar{y}\)</span> 偏离 <span class="math inline">\(r*sd\)</span> 个单位，也就是<span class="math inline">\(y\)</span> is fewer sd away from <span class="math inline">\(\bar{y}\)</span> than <span class="math inline">\(x\)</span> is from <span class="math inline">\(\bar{x}\)</span>.<br>
i.e.&nbsp;Football shaped scatter, exam scores. my becaused by regression fallacy.</p>
<p>Note: <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> and <span class="math inline">\(y\)</span> to <span class="math inline">\(x\)</span> are two different regression line, cannot predict each other.</p>
<p>回归中的正态估计？<br>
在回归线（football shape scatter)中的某一点<span class="math inline">\(x\)</span>处，<span class="math inline">\(y\)</span>服从于正态分布 即： <span class="math inline">\(\frac{Y - y(predict)|x}{\sqrt{1 - r^2}s_y}\)</span></p>
<p>如何检查回归使用是否正确？<br>
Residual plot. 残差就真实值与预测值的差. it should be a unstructured horizontal band. curved plot: not liner;but the data can be <span class="math inline">\(\sqrt{}\)</span> or log transformation to liner to analyze.</p>
<p>scatter arises: heteroscedastic(may produce homoscedastic by y variable transformation, and it may result in a non-liner scatter , which require a second transformation in of x to fix)</p>
<p>离群值 outliers? 离<span class="math inline">\(x\)</span>均值很远的<span class="math inline">\(x\)</span>可能会对回归线的构建有很大的影响（influential point）,会使得回归线向它偏离，无法用残差图检验。</p>
<p>一些问题： - 预测<span class="math inline">\(y\)</span>时，<span class="math inline">\(x\)</span>应该在其范围之中，超出<span class="math inline">\(x\)</span>的取值范围以后可能就不是线性关系。<br>
- 对总结数据注意，比如平均值，它们的变化更小，相关性？<br>
<span class="math inline">\(R^2\)</span>,可以被回归线解释的部分，<span class="math inline">\(1 - r^2\)</span>就是不能解释的，就是残差。</p>
</section>
</section>
<section id="第四篇-我们距离真相还有多远置信区间和假设检验" class="level1">
<h1>第四篇 我们距离真相还有多远——置信区间和假设检验</h1>
<section id="第一章-confidence-interval" class="level2">
<h2 class="anchored" data-anchor-id="第一章-confidence-interval">第一章 Confidence interval</h2>
<p>SE gives the chance error, confidence interval give a more precise statement.<br>
已知一个样本统计量的分布，那么每一次的抽样我们可以说有95%几率该样本的统计量大小不会偏离该总体参数的2个SE(如果该统计量服从于正态分布)，也就是可以说每一次抽样得到到统计量，我们都有95%的把握说总体参数不会偏离超过2SE于该统计量。每一次的抽样都可以得到一个置信区间。<br>
注意：置信区间随着每一次抽样变化而变化，但是总体参数是一个固定的值。</p>
<p>confidence = estimate +/- zSE(if statistic ~ normal distribution)</p>
<p>总体方差差未知？<br>
bootstrap：用样本方差代替得到一个估计置信区间。</p>
<p>More：置信区间的大小由zSE决定，称作<em>margin of error</em>,因为 <span class="math inline">\(SE = \frac{\sigma}{\sqrt{n}}\)</span> ， 所以可以通过增大样本<em>size</em>减少区间。 同样也可减少z减少区间，比如80%区间。<br>
百分数的 95%置信区间： estimated percentage +/- <span class="math inline">\(\sqrt{n}\)</span><br>
因为 <span class="math inline">\(\sigma = \sqrt{p(1 - p)}\)</span> &lt; <span class="math inline">\(\frac{1}{2}\)</span></p>
</section>
<section id="第二章-假设检验原理" class="level2">
<h2 class="anchored" data-anchor-id="第二章-假设检验原理">第二章 假设检验原理</h2>
<p>假设检验的逻辑？<br>
设定零假设，备择假设，收集数据并评估该数据是否满足零假设从而接受零假设或拒绝，零假设一般是什么都没有发生，所以我们想要拒绝它，导致假设检验的逻辑不是很直接。</p>
<p>检验统计量? test statistic<br>
A test statistic measures how far away the data are from what we would expect if H0 is true. i.e z-statistic: <span class="math display">\[
z = \frac{observed - expected}{SE}
\]</span></p>
<blockquote class="blockquote">
<p>观测值是一个用于评估H0的统计量，expected and SE are the expected value and SE of the this statistic, computed under the assumption H0 is true.</p>
</blockquote>
<p>p value is the probability of getting a value of z as extreme or more extreme than the observed z, assuming HO is true.</p>
<p>Note:Ho 是否正确是 一个确定的事，p值只是给出了在H0为真的假设下,观察到如此极端值得概率大小。</p>
<p>实际上当我们进行z检验时，我们用观测统计量 - 期望统计量，然后除以统计量的SE，计算出观测统计量在零假设的情况下偏离期望值多少个<em>sd</em>。实际上样本的统计量的SE需要用总体方差进行计算，在sample size &gt; 20的情况下可以直接用样本<em>sd</em>代替总体<em>sd</em>，进行近似求解sample SE。如果sample size &lt; 20，用样本<em>sd</em>代替总体sd计算那么其服从于t(n-1), 置信区间：<span class="math inline">\(\bar{x} +/- t_{n-1}SE\)</span></p>
<p>其他： 1. 统计学上的显著不能说明效应大小很重要，因为大的样本数目可以减少SE,使得样本统计量的分布更加集中，那么只要一个很小的偏离就可以具有统计学上的显著。<br>
2. 95%的置信区间包括了所有零假设不会被拒绝的值，对于一个双端检验p值为0.05。<br>
3. 两类错误：H0为真,拒绝了type1 false positive,H0为假，接受了type2 error false negative</p>
</section>
<section id="第三章-假设检验之z检验以及t检验" class="level2">
<h2 class="anchored" data-anchor-id="第三章-假设检验之z检验以及t检验">第三章 假设检验之z检验以及t检验</h2>
<p>Two sample z-test <span class="math display">\[
z = \frac{observed\ difference - expected\ difference}{SE\ of\ difference} = \frac{(\hat{p}_2 - \hat{p}_1) - (p_2 - p_1)}{SE\ of\ difference}
\]</span> If the two sample are independent: <span class="math display">\[
SE(\bar{x}_2 - \bar{x}_1) = \sqrt{(SE(\bar{x}_1))^2 + (SE(\bar{x}_2))^2 }
\]</span></p>
<p>and <span class="math inline">\(SE(\bar{x}_1) = \frac{\sigma_1}{\sqrt{n_1}}\)</span> is estimated by <span class="math inline">\(\frac{s_1}{\sqrt{n_1}}\)</span> if sample size n1, n2 are not large, then the p-value neeed to computed from the t-distribution.</p>
<p>if assuming <span class="math inline">\(\sigma_1 = \sigma_2\)</span>,then pooled estimate for <span class="math inline">\(\sigma_1 = \sigma_2\)</span> ,given by <span class="math display">\[
s_{pooled}^2 = \frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}
\]</span></p>
<p>Paired-difference test the independent assumption is in the sampling of the couples H0: population difference is zero <span class="math inline">\(t = \frac{\bar{d} - 0}{SE(\bar{d})}\)</span>, where <span class="math inline">\(d_i\)</span> is the difference of the <em>i</em>th couple. <span class="math inline">\(SE(\bar{d}) = \frac{\sigma_d}{\sqrt{n}}\)</span>, estimate <span class="math inline">\(\sigma_d\)</span> by <span class="math inline">\(s_d\)</span></p>
<p><strong>The sign test</strong></p>
</section>
<section id="第四章-假设检验之卡方检验类别变量研究" class="level2">
<h2 class="anchored" data-anchor-id="第四章-假设检验之卡方检验类别变量研究">第四章 假设检验之卡方检验——类别变量研究</h2>
<p><strong>Testing of goodness-of-fit</strong>:研究一个分类变量的分布和已知分布是否一致。 H0: the color distribution is given by that table <span class="math display">\[
\chi^2_{n-1} = \sum_{all\ categories} \frac{(observed - expected)^2}{expected}
\]</span> 期望值来自于已知分布</p>
<p><strong>Testing homogeneity</strong>：<span class="math inline">\(\chi^2 -test\ of \ homogeneity\)</span> tests that the distribution of a categorical variable(color) is the same for serval populations(milk, peanut,caramel);检验一个分类变量在不同的总体中的分布是否一致。 <span class="math display">\[
\chi^2 (no.\ of\ columns -1 )(no.\ of\ rows - 1) = \sum_{all\ cells} \frac{(observed - expected)^2}{expected}
\]</span> 期望值来自于把不同总体合并为一个总体，计算该分类变量在所有总体中概率分布。</p>
<p><strong>Testing independence</strong> computed exactly as in the case of testing homogeneity. 比较图（待粘贴）</p>
</section>
<section id="第五章-假设检验之f检验方差分析" class="level2">
<h2 class="anchored" data-anchor-id="第五章-假设检验之f检验方差分析">第五章 假设检验之F检验——方差分析</h2>
<p>通过比值比较组内差异和组间差异的大小。 Compare the sample variance of the means to the sample variance within the groups. Analysis of Variance(ANOVA)</p>
<p>k groups and the <span class="math inline">\(j\)</span>th group has <span class="math inline">\(n_j\)</span> observations:</p>
<p>There are total <span class="math inline">\(N = n_1 + ... + n_k\)</span> observations. Sample meen of <em>j</em>th group :</p>
<p><span class="math inline">\(\bar{y_j} = \frac{1}{n_j}\sum_{i=1}^{n_j}y_{ij}\)</span></p>
<p>Overall sampeld mean:</p>
<p><span class="math inline">\(\bar{y} = \frac{1}{N}\sum_{j=1}^{k}\sum_{i=1}^{n_j}y_{ij}\)</span></p>
<p>The treatment sum of squares : <span class="math display">\[
SST = \sum_j\sum_i(\bar{y_j} - \bar{y})^2
\]</span></p>
<p>has k-1 degrees of freedom.</p>
<p>The treatment mean square: <span class="math display">\[
MST = \frac{SST}{k - 1}
\]</span> Measures the variability of the treatment mean <span class="math inline">\(\bar{y_j}\)</span></p>
<p>The error sum of suqares : <span class="math display">\[
SSE = \sum_j\sum_i(\bar{y}_ij -  \bar{y_j})^2
\]</span> has <span class="math inline">\(N - k\)</span> degress of freedom. the error mean mean square : <span class="math display">\[
MSE = \frac{SSE}{N - k}
\]</span> Measures the varibility within the groups.</p>
<p>Compare the variation between the groups to the varition within the groups: <span class="math display">\[
F = \frac{MST}{MSE}
\]</span> follows <em>F</em>-distribution with <em>k</em> - 1 and <em>N - K</em> degress of freedom. under null hypothesis ,it shoud be close to 1(not exactly for chane error.)</p>
<p>the ANOVA table: (待粘贴)</p>
<p>The one-way ANOVA model: <span class="math display">\[
y_{ij} = \mu_j + \epsilon_{ij} (\mu_j: mean\ of\ jth\  group, \epsilon_{ij} \sim N(0, \sigma^2))
\]</span></p>
<p>so the null hypothesis: <span class="math display">\[
\mu_1 = \mu_2 = ...\mu_k
\]</span></p>
<p>group mean’s devation away from the overall mean: <span class="math inline">\(\tau_j = \mu_j - \mu\)</span></p>
<p>so the the model: <span class="math display">\[
y_{ij} = \mu + \tau_j + \epsilon_{ij}
\]</span> where <span class="math inline">\(\tau\)</span> called treatment effect of group <em>j</em>. Then the null hypothesis is <span class="math display">\[
H_0 : \tau_1 = \tau_2 = ... = \tau_k = 0
\]</span></p>
<p>estimate overall mean <span class="math inline">\(\mu\)</span> by the ‘grand mean’ <span class="math inline">\(\bar{y}\)</span>, then the estimate of <span class="math inline">\(\tau_j = \mu_j - \bar{y}\)</span>. the estimate of <span class="math inline">\(\epsilon\)</span> is the residual <span class="math inline">\(y_{ij} - y_j\)</span></p>
<p>corresonding to the model <span class="math inline">\(y_{ij} = \mu + \tau + \epsilon_ij\)</span> wecan write <span class="math inline">\(y_{ij}\)</span> as the sum of the corresponding estimates: <span class="math display">\[
y_{ij} = \bar{y} + (\bar{y_j} - \bar{y}) + (y_{ij} - \bar{y_{j}})
\]</span></p>
<p>it turns out that such a decomposition is also true for the sum of squares: <span class="math display">\[
\sum_j\sum_i(y_{ij} - \bar{y})^2 = \sum_j\sum_i(y_j - \bar{y})^2 + \sum_j\sum_i(y_ij - bar{y_j})^2
\]</span> <span class="math display">\[
TSS = SST             +            SSE
\]</span> it split the total variation into weo ‘sources’: SST and SSE.</p>
<p><strong>MORE</strong>: The F-test assumes that all group have the same <span class="math inline">\(\sigma^2\)</span>, it can be roughly checked with side-by-side boxplots, and there are also formal test. another assumption: data are independent within and across group. it would be the case if the data were assigned to treatment at random . F-test give conclusion not eual,how thy differ, examine all paires of means of a two sample t-test using <span class="math inline">\(s_{pooled} = \sqrt{MSE}\)</span>, multiple tests, adjustment is necessary such as Bonferroni adjustment.</p>
</section>
<section id="第六章-假设检验之多重假设检验" class="level2">
<h2 class="anchored" data-anchor-id="第六章-假设检验之多重假设检验">第六章 假设检验之多重假设检验</h2>
<p>p value &lt; 1% <span class="math inline">\(\rightarrow{}\)</span> test is ‘highly significant’ interpretation: If there is no effect, then there is only 1% chance to get such a highly significant result.</p>
<p>but if we do 800 tests, then enen their id no effect at all we expect to see 800* 1% = 8 highly results just by chance.</p>
<p>this is called multiple testing fallacy or look-elsewhere effect.(leads to data snooping or in other words, data dredging.)</p>
<p>Data snooping and other problems have lead to a crisis with regard to replicability (getting similar conclusions with different samples, procedures and data analysis methods) and reproducibility (getting the same results when using the same data and methods of analysis.)</p>
<p>Bonferroni correction: If there are m tests, multiply the p-values by m</p>
<p>False Discovery Proportion (FDP): <span class="math display">\[
FDP = \frac{number\ of\ false\ discoveries}
{total\ number\ of\ discoveries}
\]</span> where a ‘discovery’ occurs when a test rejects the null hypothesis.</p>
<p>False discovery rate (FDR): Controls the expected proportion of discoveries that are false. Benjamini-Hochberg procedure to control the FDR at level α = 5% (say): 1. Sort the p-values: p(1) ≤ . . . ≤ p(m) 2. Find the largest k such that p(k) ≤ k m <span class="math inline">\(\alpha\)</span> 3. Declare discoveries for all tests i from 1 to k</p>
<p>Using a validation set: Split the data into a model-building set and a validation set before the analysis</p>
</section>
</section>
<section id="第五篇-从演绎到推断计算机重抽样" class="level1">
<h1>第五篇 从演绎到推断——计算机重抽样</h1>
<p>Monte Carlo Method:从总体中多次抽样，计算多个样本的统计量，得到样本统计量的均值与SE的估计。 Bootstrap: plug-in principle, 从一个样本中多次放回抽样计算多个样本统计量，得到样本统计量的均值与SE。Nonparametric bootstrap parametric bootstrap, bloc bootstrap.</p>
<p><strong>bootstrap confidence interval</strong> <strong>bootstrapping for regression</strong></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/person-c\.github\.io\/doc\.cying\.org\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>